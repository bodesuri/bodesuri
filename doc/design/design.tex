\documentclass[12pt,halfparskip]{scrartcl}

\newcommand{\dokumenttitel}{Design}
\usepackage{../bodesuri}


\begin{document}

\input{../titelseite}

\section{Architekturübersicht}

Bodesuri ist über mehrere Rechner verteilt. Es gibt vier Clients und einen Server pro Spiel. Der Client und der Server sind getrennte Programme, welche aber eine gemeinsame Codebasis haben.

Zwischen Client und Server werden Nachrichten verschiedener Typen zur Synchronisation ausgetauscht. Ein Beispiel anhand der Züge: Der Server sendet dem Spieler, der am Zug ist, eine Zugaufforderung. Auf die antwortet der Spieler mit einem Zug, welcher den Spieler, die gezogene Karte und die Bewegung der Figuren enthält. Der Server verteilt dann diese Informationen als Zuginformation an alle Spieler, wie man in Abbildung~\vref{fig:client_server} sehen kann.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.6 \textwidth]{client_server}
	\caption{Kommunikation zwischen Client \& Server}
	\label{fig:client_server}
\end{figure}

Die Validierung der gespielten Züge geschieht sowohl auf dem Client als auch auf dem Server. Der Server ist ausserdem noch zuständig für die Koordination des Spielablaufs und für die Kommunikation zwischen den Spielern.

\clearpage
\section{Design Pakete}
\label{design_pakete}

\subsection{Logische Sicht}
\label{sub:logische_sicht}

\subsubsection{Schichtenarchitektur}
\label{sub:schichtenarchitektur}
Für die logische Strukturierung des Projektes wird eine vierschichtige Architektur verwendet, wie in Abbildung~\vref{fig:architektur_schichten} dargestellt. Dabei setzt jede Schicht direkt auf den Diensten der darunterliegenden Schichten auf. Schichten können transparent sein. Dadurch ergeben sich wenige Indirektionen und eine einfache Nutzung der Dienste einer Schicht. Wo möglich und sinnvoll, werden Schnittstellen zwischen Schichten durch eine Fassade gebündelt, um die Kopplung zwischen den Schichten zu verringern. Dadurch lassen sich die Schnittstellen für die Schichten auch klarer definieren und sind einfacher zu nutzen. Im UI wird das MVC-Konzept verwendet, da eine komplexe Darstellungslogik durch das Spiel gegeben ist.
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{architektur_schichten}
	\caption{Schichtenarchitektur}
	\label{fig:architektur_schichten}
\end{figure}
\clearpage
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{architektur_partitions}
	\caption{Partitionen in der Architektur}
	\label{fig:architektur_partitions}
\end{figure}

\clearpage

\subsubsection{Package pd}
\label{ssub:package_pd}
\subparagraph{Beschreibung}
In der Problem-Domain-Schicht wird die gesamte Spiellogik gekapselt. Sie wird direkt von der darüberliegenden Applikationsschicht verwendet.

\subparagraph{Schnittstellen}
\label{ssub:schnittstellen}
\begin{itemize}
	\item Package pd.zugsystem wird von applikation.zugentgegennahme verwendet, um Züge zu verarbeiten.
\end{itemize}

\subsubsection{Package pd.karten}
\label{ssub:package_pd_karten}
\subparagraph{Beschreibung}
Beinhaltet alle Karten, die Kartenfarben, das Deck und den Kartengeber. 

\subparagraph{Schnittstellen}
\label{ssub:schnittstellen}
\begin{itemize}
	\item Als Einstiegspunkt für die Karten wird der Kartengeber verwendet, welcher das Mischen und das Ziehen einer Karte vom Stapel bereitstellt.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8 \textwidth]{pd_kartengeber}
	\caption{Klassendiagramm Kartengeber}
	\label{fig:pd_kartengeber}
\end{figure}

\clearpage
\subsubsection{Package pd.regelsystem, pd.zugsystem}
\label{ssub:package_pd_regelsystem}
\subparagraph{Beschreibung}
Das Regel- und das Zugsystem sind eng miteinander verbunden. Sie nehmen die Aufgaben der Problem-Domain-Schicht wahr und stellen die Validierung der Züge sicher und berechnen die daraus resultierenden Aktionen in der Problem-Domain (Figur von Feld X auf Feld Y verschieben).

\subparagraph{Schnittstellen}
\label{ssub:schnittstellen}
\begin{itemize}
	\item Die Zugeingabe fasst die Informationen zusammen, die für einen Zug benötigt werden und über sie wird validiert, was zu einem ausführbaren Zug führt.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{pd_regelsystem}
	\caption{Klassendiagramm Regelsystem}
	\label{fig:pd_regelsystem}
\end{figure}

\clearpage
\subsubsection{Package pd.brett, pd.spieler}
\label{ssub:package_pd_brett}
\subparagraph{Beschreibung}
Die beiden Packages sind eng miteinander verbunden und stellen die Abstraktion des Bretts (welches die Felder enthält), der Figuren und des Spielers in der Problem-Domain dar.

\subparagraph{Schnittstellen}
\begin{itemize}
	\item Der Einstiegspunkt ist das Spiel, da es das Brett, den Kartengeber und die Spieler enthält.
\end{itemize}

\label{ssub:diagramme}
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{pd_brett}
	\caption{Klassendiagramm Brett und Figuren}
	\label{fig:pd_brett}
\end{figure}

\clearpage
\subsubsection{Package pd.serialisierung}

\subparagraph{Beschreibung}
Implementiert die abstrakten Klassen von dienste.serialisierung, um die Serialisierung von Klassen der Problem-Domain zu ermöglichen.

\subparagraph{Schnittstellen}
\begin{itemize}
	\item Bietet eine Basisklasse (BodesuriCodierbaresObjekt) für die Klassen der Problem-Domain an, die serialisiert werden können.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5 \textwidth]{kd_pd_serialisierung}
	\caption{Klassendiagramm Serialisierung in PD}
	\label{fig:kd_pd_serialisierung}
\end{figure}

\clearpage
\subsubsection{Package dienste.automat}
\label{ssub:package_dienste}
\subparagraph{Beschreibung}
Beinhaltet einen Zustandsautomaten der im Client und im Server für eine gezielte Abarbeitung des Spielablaufs sorgt. Der Automat wechselt aufgrund externer Events auf vorher definierten Bahnen zwischen den Zuständen hin und her. 

Der Automat bietet zwei Betriebsmodi an:
\begin{itemize}
	\item Eigenständiger automatischer Betrieb in einem dedizierte Thread. Der Automat liest neue Ereiggnise aus einer Synched Queue und verarbeitet diese. Sind keine Ereignisse anstehend blockiert der Automat
	\item Ferngesteuerter integrierter Betrieb. Der Automat wird vom Caller bei anstehnenden Ereignissen  aufgerufen und verarbeitet dieser exkat ein Ereignis (inklusive den dazugehörenden Zuständen) und übergibt anschliessend die Kontrolle wieder dem Caller. Der Modus eignet sich speziell für Unterautomaten bei welchen man keinen zusätzlichen Thread und eine seperate Ereignisqueue einsetzen möchte. Der Hauptautomat liest die Events ein und gibt sie direkt dem Unterautomaten weiter. 
\end{itemize}

\subparagraph{Schnittstellen}
\label{ssub:schnittstellen}
\begin{itemize}
	\item Der Automat muss von den darüberliegenden Klassen abgeleitet und spezifisch implementiert werden.
\end{itemize}	

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dienste_automat_klassendiagramm}
	\caption{Klassendiagramm Automat}
	\label{fig:dienste_serialisierung}
\end{figure}

\clearpage
\subsubsection{Package dienste.serialisierung}

\subparagraph{Beschreibung}
Dieses Package ist für die Serialisierung und Deserialisierung der Java-Objekte zuständig, welche anschliessend über das Netzwerk versendet werden. 

\subparagraph{Schnittstellen}
\begin{itemize}
	\item Die abstrakte Klasse CodierbaresObjekt muss vom Benutzer dieses Packages implementiert werden. Dabei müssen die Methoden \texttt{getCodierer} und \texttt{getCodiertesObjekt} überschrieben werden. \texttt{getCodiertesObjekt} sollte ein neues konkretes CodiertesObjekt (z.\,B. BodesuriCodiertesObjekt) erstellen.
	\item Die zweite abstrakte Klasse CodiertesObjekt muss auch implementiert werden. Es muss nur \texttt{getCodierer} überschrieben werden, um den gleichen Codierer zurückzugeben wie bei CodierbaresObjekt.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{kd_dienste_serialisierung}
	\caption{Klassendiagramm Serialisierung in Dienste}
	\label{fig:kd_dienste_serialisierung}
\end{figure}

\clearpage
\subsubsection{Package dienste.netzwerk}
\label{ssub:package_dienste_netzwerk}
\subparagraph{Beschreibung}
Dieses Package kapselt die Socket-Schnittstelle von Java und bietet Dienste für die Netzwerkkommunikation an.

\subparagraph{Schnittstellen}
\label{ssub:schnittstellen}
\begin{itemize}
	\item dienste.netzwerk verwendet die Klassen Event und EventQueue für die Kommunikation mit den darüberliegenden Schichten.
% FIXME: Reto stimmt so nümm (Reto)
	\item Die Kommunikation mit dem Netzwerk findet über die Bibliotheken java.net statt.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9 \textwidth]{dienste_netzwerk_client}
	\caption{Klassendiagramm Client in Netzwerk}
	\label{fig:dienste_netzwerk_client}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9 \textwidth]{dienste_netzwerk_server}
	\caption{Klassendiagramm Server in Netzwerk}
	\label{fig:dienste_netzwerk_server}
\end{figure}

\clearpage
\subsubsection{Package ui}
\label{ssub:package_ui}
Die UI-Schicht ist für die graphische Darstellung verantwortlich. Sie kommuniziert mit der Applikationsschicht top-down über direkte Assoziationen und bottom-up über Observer.

\begin{description}
  \item[ui.geteiltes] Klassen, die in verschiedenen Views verwendet werden.
	\item[ui.lobby] Ist für die Darstellung der Lobby verantwortlich.
	\item[ui.ressourcen] Es beinhaltet die Ressourcen, die für das Optische benötigt werden.
	\item[ui.spiel] Wird verwendet um die Views des Spieles zusammenzuführen.
	\item[ui.spiel.brett] Kümmert sich um die Darstellung des Brettes.
	\item[ui.spiel.steuerung] Dient als Steuerung der Karten und Sonderfunktionen.
	\item[ui.verbinden] Dienst zur Erstellung der Verbindung mit dem Server.
\end{description}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{ui_alle}
	\caption{Klassendiagramm UI}
	\label{fig:ui_alle}
\end{figure}

\clearpage
\subsubsection{Package applikation}
\label{ssub:package_applikation}
\subparagraph{Beschreibung}
Die Applikationsschicht ist für die Zustandssynchronisation (Spielstände usw.) verantwortlich.

\subsubsection{Package applikation.zugentgegennahme}
\label{ssub:package_applikation_zugentgegennahme}
\subparagraph{Beschreibung}
\label{ssub:beschreibung}
Die Zugentgegennahme sorgt für die Verbindung vom UI zur Problem-Domain. Durch das Klicken (ziehen der Figur) im UI werden Züge an die Problem-Domain weitergeleitet und die Validierung eingeleitet.

\subparagraph{Schnittstellen}
\label{ssub:schnittstellen}
\begin{itemize}
	\item Bietet die Methode \texttt{ziehen} an, welche die Zugentgegennahme in einen neuen Status versetzt.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{applikation_zugentgegennahme}
	\caption{Klassendiagramm Zugentgegennahme}
	\label{fig:applikation_zugentgegennahme}
\end{figure}

\clearpage
\subsubsection{Package applikation.client}
\label{ssub:package_applikation_client}
\subparagraph{Beschreibung}
\label{ssub:beschreibung}
Der Zustandsautomat des Clients und dessen Zustände. Sorgt für den korrekten Ablauf des Spiels auf der Client-Seite. Verarbeitet die eintretenden Events von GUI und Netzwerk und löst entsprechende Aktionen aus.

\subparagraph{Schnittstellen}
\label{ssub:schnittstellen}
\begin{itemize}
	\item Bietet verschiedenste Instanzvariablen für das GUI und die zum Server gehörenden Zustände an.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{kd_applikation_client}
	\caption{Klassendiagramm Client in Applikation}
	\label{fig:kd_applikation_client}
\end{figure}

\clearpage
\subsubsection{Package applikation.server}
\label{ssub:package_applikation_server}
\subparagraph{Beschreibung}
\label{ssub:beschreibung}
Der Zustandsautomat des Servers und dessen Zustände. Sorgt für den korrekten Ablauf des Spiels auf der Server-Seite. Verarbeitet die eintretenden Events vom Netzwerk und löst entsprechende Aktionen aus, um den Spielablauf zu steuern.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{kd_applikation_server}
	\caption{Klassendiagramm Server in Applikation}
	\label{fig:kd_applikation_server}
\end{figure}

\clearpage
\subsubsection{Package applikation.events}
\label{ssub:package_applikation_events}
\subparagraph{Beschreibung}
\label{ssub:beschreibung}
Dieses Package beinhaltet die Events, die eintreten können und um deren Behandlung sich der Automat kümmert.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{kd_applikation_events}
	\caption{Klassendiagramm Events}
	\label{fig:kd_applikation_events}
\end{figure}

\subsubsection{Package applikation.nachrichten}
\label{ssub:package_applikation_nachrichten}
\subparagraph{Beschreibung}
\label{ssub:beschreibung}
Dieses Package beinhaltet alle möglichen Nachrichtentypen, die zur Kommunikation zwischen Client und Server verwendet werden.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{kd_applikation_nachricht}
	\caption{Klassendiagramm Nachrichten}
	\label{fig:kd_applikation_nachricht}
\end{figure}
\clearpage

\subsection{Prozesse \& Threads}
\label{sub:prozesse_threads}

Ein reguläres Bodesuri-Spiel besteht aus fünf eigenständigen Komponenten. Dies sind die vier Clients und der zentrale Server. Zwischen den Clients und dem Server besteht je ein TCP Socket. 

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{prozesse_und_threads}
	\caption{Prozesse \& Threads}
	\label{fig:prozesse_und_threads}
\end{figure}

\clearpage
\subsubsection{Client-Threads}
\label{ssub:client_threads}

\paragraph{Main-Thread}
\label{ssub:main_thread}

Der Main-Thread des Clients ist für die geordnete Koordination zwischen dem Spieler (via GUI) und den anderen Clients (via Server) zuständig.


\begin{tabular}{@{} l p{12.5cm}}
\textbf{Klasse}       & BodesuriClient \\
\textbf{Anzahl}       & 1 \\
\textbf{Gestartet}    & Bei Prozessbeginn \\
\textbf{Beendet}      & Bei Programmende
\end{tabular}

\paragraph{Empfänger-Thread}
\label{ssub:empfänger_thread}

Der Empfänger-Thread ist für den Empfang von Netzwerk-Nachrichten zuständig. Er liest aus einem java.net.Socket und speichert die eingegangenen Nachrichten über das Briefkasten-Interface in der EventQueue.

\begin{tabular}{@{} l p{12.5cm}}
\textbf{Klasse}       & Empfaenger \\
\textbf{Anzahl}       & 1 \\
\textbf{Gestartet}    & Bei Verbindungsaufbau durch den Main-Thread (Klasse Endpunkt) \\
\textbf{Beendet}      & Bei Verbindungsabbau durch den Main-Thread (Klasse Endpunkt) oder bei Fehlern selbsttändig.
\end{tabular}


\paragraph{Swing-Threads}
\label{ssub:swing_threads}

Swing startet intern verschiedene Threads. Die genauen Abläufe und Struktur dieser Threads sind für diese Dokumentation nicht relevant.

\begin{tabular}{@{} l p{12.5cm}}
\textbf{Klasse}       & AWK-AppKit \\
\textbf{Anzahl}       & 1..* \\
\textbf{Gestartet}    & Durch Swing \\
\textbf{Beendet}      & N/A
% TODO: Reto: Abklären da gibts doch sicher ne methode oder so (reto)

\end{tabular}

\clearpage
\subsubsection{Server Threads}
\label{ssub:server}

Der Server ist für die Koordination der einzelnen Clients zuständig.

\begin{tabular}{@{} l p{12.5cm}}
\textbf{Klasse}       & BodesuriServer \\
\textbf{Anzahl}       & 1 \\
\textbf{Gestartet}    & bei Prozessbeginn \\
\textbf{Beendet}      & Bei Spielende oder bei schweren Fehlern
\end{tabular}

\paragraph{Daemon}
\label{ssub:daemon}

Der Daemon ist ein Teil des Servers. Er nimmt eingehende Verbindungen entgegen und meldet diese über das BriefkastenInterface (via EventQueue) an den Nutzer des Servers.

\begin{tabular}{@{} l p{12.5cm}}
\textbf{Klasse}       & Daemon \\
\textbf{Anzahl}       & 1 \\
\textbf{Gestartet}    & Durch den Main-Thread (Klasse Server) gestartet \\
\textbf{Beendet}      & Bei Programmende
\end{tabular}

\paragraph{Empfänger-Thread}
\label{ssub:empfänger_thread}

Der Empfänger-Thread ist für den Empfang von Netzwerk-Nachrichten zuständig. Er liest aus einem java.net.Socket und speichert die eingegangenen Nachrichten über das Briefkasten-Interface in der EventQueue.

Es wird pro offene Verbindung ein Empfänger gestartet.

\begin{tabular}{@{} l p{12.5cm}}
\textbf{Klasse}       & Empfänger \\
\textbf{Anzahl}       & 1..4 \\
\textbf{Gestartet}    & Durch den Daemon bei eingehenden Verbindungen  \\
\textbf{Beendet}      & Bei Verbindungsabbau durch den Main-Thread
\end{tabular}

\clearpage
\section{Spielablauf \& -zustände}
\label{spielzustaende_nachrichten}
\subsection{Zustände Client}
\label{sub:zustände_client}
Abbildung~\vref{fig:zd_applikation_bodesuriclient} zeigt den Ablauf der Zustände des Clients. Zustände in grün sind passive Zustände.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{zd_applikation_bodesuriclient}
	\caption{Zustandsdiagramm Client}
	\label{fig:zd_applikation_bodesuriclient}
\end{figure}

\subsubsection{ProgrammStart}
\label{ssub:programmstart}
Zustand in welchem der Automat beim Start ist. Öffnet den VerbindenView und geht direkt in den Zustand VerbindungErfassen über.


\subsubsection{VerbindungErfassen}
\label{ssub:verbinungerfassen}
Zustand wenn der Spieler die Verbindungsdaten eingeben muss. Wenn ein VerbindeEvent eintrifft, wird der Zustand Lobby aufgerufen.

\subsubsection{Lobby}
\label{ssub:lobby}
Zustand wenn der Spieler in der Lobby ist.
\begin{itemize}
	\item Wenn eine SpielStartNachricht eintrifft, wird der Zustand SpielStart aufgerufen.
	\item Wenn eine BeitrittsInformation eintrifft, wird werden die Informationen über die beigetretenen Spieler aktualisiert. Der Zustand wird nicht gewechselt.
	\item Wenn eine BeitrittVerweigertNachricht eintrifft, wird das Spiel beendet.
\end{itemize}

\subsubsection{SpielStart}
\label{ssub:spielstart}
Zustand in welchem das Spiel (BodesuriView) gestartet wird. Geht direkt in NichtAmZug über.

\subsubsection{NichtAmZug}
\label{ssub:nichtamzug}
Zustand wenn der Spieler nicht am Zug ist.
\begin{itemize}
	\item 	Wenn eine ZugAufforderung eintrifft, wird der Zustand AmZug aufgerufen.
	\item 	Wenn eine AktuellerSpielerInformation eintrifft, wird der aktuelle Spieler dargestellt, der Zustand aber nicht gewechselt.
	\item 	Wenn eine ZugEingabe eintrifft, wird Zug aus der Eingabe visualisiert. Der Zustand wird nicht gewechselt.
	\item 	Wenn eine RundenStart-Nachricht eintrifft, werden die erhaltenen Karten gespeichert und der Zustand StarteRunde aufgerufen.
	\item 	Wenn eine AufgabeInformation eintrifft, wird der Spieler, welcher aufgegeben hat, im UI angepasst. Der Zustand wird nicht gewechselt.
	\item 	Wenn eine SpielFertigNachricht eintrifft, wird der Gewinner angezeigt und SpielEnde aufgerufen.
\end{itemize}

\subsubsection{StarteRunde}
\label{ssub:starterunde}
Zustand wenn eine neue Runde gestartet wird. Alle Eigenschaften der Spieler werden zurückgesetzt. Der Automat geht nach KarteTauschenAuswaehlen über.

\subsubsection{KarteTauschenAuswaehlen}
\label{ssub:kartetauschenauswaehlen}
Zustand in dem wir warten bis der Spieler die Karte, die er tauschen möchte, ausgewählt hat. Tritt KarteGewaehltEvent ein, gehen wir in den Zustand KarteTauschenBekommen über.

\subsubsection{KarteTauschenBekommen}
\label{ssub:kartetauschenbekommen}
Zustand wenn wir auf die Karte, die wir von unserem Mitspieler erhalten, warten. Wenn sie eintrifft, wird der Zustand NichtAmZug aufgerufen.

\subsubsection{AmZug}
\label{ssub:amzug}
Zustand in welchem der Spieler am Zug ist. Erstellt einen ZugAutomaten, der sich um das Erfassen und Validieren eines Zuges kümmert. Eintreffende Events werden direkt an den ZugAutomaten weitergeleitet. Dieser sendet einen ZugErfasstEvent wenn er fertig ist. Der Event wird versandt und der Automat geht nach NichtAmZug über.

\subsubsection{SpielEnde}
\label{ssub:spielende}
Zustand in welchem sich dem Automat befindet wenn wir das Spiel beenden wollen. In diesem Zustand werden Events, die möglicherweise noch in der Queue warten, konsumiert, das UI heruntergefahren, die Verbindung zum Server geschlossen und der Automat beendet.

\subsection{Zustände ZugAutomat}
\label{sub:zustände_zugautomat}
Die Erfassung eines Zuges wurde aus dem Client-Automaten ausgelagert. Abbildung~\vref{fig:zd_applikation_bodesuriserver} zeigt den Ablauf der Zustände des ZugAutomaten. Zustände in grün sind passive Zustände.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{zd_applikation_zugautomat}
	\caption{Zustandsdiagramm ZugAutomat}
	\label{fig:zd_applikation_zugautomat}
\end{figure}

\subsubsection{KarteWaehlen}
\label{ssub:kartewaehlen}
Zustand wenn der Spieler eine Karte auswählen muss. Wenn der KarteGewaehltEvent eintritt, wird der Zustand StartWaehlen aufgerufen.

\subsubsection{StartWaehlen}
\label{ssub:startwaehlen}
Zustand wenn der Spieler das Startfeld wählen muss.
\begin{itemize}
	\item Trifft ein FeldGewaehltEvent ein, wird das Feld überprüft. Ergibt die Wahl Sinn, wird nach ZielWaehlen gewechselt. Sonst bleiben wir in diesem Zustand.
	\item Trifft ein KarteGewaehltEvent ein (der Spieler hat eine andere Karte ausgewählt) wird nach KarteWaehlen gewechselt.
	\item Trifft ein FeldAbgewaehltEvent ein, wird das Brett zurückgesetzt. Wir bleiben aber in diesem Zustand.
\end{itemize}

\subsubsection{ZielWaehlen}
\label{ssub:zielwaehlen}
Zustand wenn der Spieler das Zielfeld wählen muss.
\begin{itemize}
	\item Trifft ein FeldGewaehltEvent ein, wird das Feld überprüft. Ergibt die Wahl Sinn, wird nach ZugValidieren gewechselt. Wurde das Startfeld ausgewählt, wird das Startfeld wieder deaktiviert und nach StartWaehlen gewechselt.
	\item Trifft ein KarteGewaehltEvent ein (der Spieler hat eine andere Karte ausgewählt), wird nach KarteWaehlen gewechselt.
	\item Trifft ein FeldAbgewaehltEvent ein, wird das Brett zurückgesetzt. Wir bleiben aber in diesem Zustand.
	\item HoverStartEvent und HoverEndeEvent aktiveren bzw. deaktivieren das Hervorheben des Weges.
\end{itemize}

\subsubsection{ZugValidieren}
\label{ssub:zugvalidieren}
Validiert den erfassten Zug.
\begin{itemize}
	\item Ist die Karte eine Sieben und es wurden noch keine 7 Felder gefahren, wechseln wir zurück nach StartWaehlen um eine weitere Bewegung zu erfassen.
	\item Ist der Zug ungültig, wird eine Fehlermeldung gezeigt und zurück nach ZielWaehlen gewechselt.
	\item Ist der Zug gültig, wird er zurück an den ClientAutomat übermittelt und nach ZugautomatAbschluss gewechselt.
\end{itemize}

\subsubsection{ZugautomatAbschluss}
\label{ssub:zugautomatabschluss}
Räumt den Zugautomaten auf. Alle Bewegungen werden zurückgesetzt, die Kartenauswahl deaktiviert, die SteuerungsButtons ausgeblendet und in ZugautomatEndZustand übergegangen.

\subsubsection{ZugautomatEndZustand}
\label{ssub:zugautomatendzustand}
Endzustand des Zugautomaten. Ignoriert alle eingehenden Events.


\subsection{Zustände Server}
\label{sub:zustände_server}

Abbildung~\vref{fig:zd_applikation_bodesuriserver} zeigt den Ablauf der Zustände des Servers.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{zd_applikation_bodesuriserver}
	\caption{Zustandsdiagramm Server}
	\label{fig:zd_applikation_bodesuriserver}
\end{figure}

\subsubsection{ServerStart}
\label{ssub:serverStart}
Server wird gestartet. Der TCP-Daemon wird initialisiert und es werden die notwenigen Vorbereitungen getroffen um Spieler zu akzeptieren.

\subsubsection{EmpfangeSpieler}
\label{ssub:empfangespieler}
Neue Spieler können mittels der Nachricht SpielBeitreten dem Spiel beitreten. Dem beigetretenen Spieler wird mit der Nachricht BeitrittBestätigung der Beitritt bestätigt.

Sobald alle Spieler komplett sind, wird in den Zustand StarteSpiel gewechselt.

\subsubsection{StarteSpiel}
\label{ssub:startespiel}
Den Spielern wird der Spielstart mit der Nachricht SpielStart angekündet. Die Partnerschaften werden, wie auf Abbildung~\vref{fig:dienste_partner} gezeigt, zwischen den Spielern ausgehandelt.\footnote{Wurde nicht implementiert.}

\subsubsection{StartRunde}
\label{ssub:startrunde}
Eine neue Runde wird gestartet und mit der Nachricht RundenStart den Spielern mitgeteilt. Es werden allen Spielern Karten ausgeteilt.

\subsubsection{KartenTauschen}
\label{ssub:kartentauschen}
Alle Spieler müssen mit ihrem Partner eine Karte tauschen. Der Server wartet bis alle Spieler die zu tauschende Karte mit der Nachricht KartenTausch gemeldet haben. Anschliessend wird die getauschte Karte mit derselben Nachricht dem Partner gemeldet.

\subsubsection{StarteZug}
\label{ssub:startezug}
Ein Zug wird gestartet. Der Server bestimmt welcher Spieler an der Reihe ist und teilt ihm dies mit der Nachricht Zugaufforderung mit. 

\subsubsection{WarteAufZug}
\label{ssub:warteaufzug}
Der Server wartet, bis der Spieler seinen Zug erfasst hat. Sobald dieser mitgeteilt wurde, wechselt der Server in den Zustand VersendeZug.

\subsubsection{SendeZug}
\label{ssub:sendezug}
Der erfasste Zug wird auf Richtigkeit geprüft und anschliessend allen Spielern mitgeteilt.

\subsubsection{ZugAbschluss}
\label{ssub:zugabschluss}
Server schliesst den Zug formell ab. Es wird geprüft, ob das Spiel beziehungsweise die Runde abgeschlossen ist und in den Zustand SpielEnde respektive RundenStart gewechselt. Ist weder das Spiel noch die Runde fertig wird in den Zustand StartZug gewechselt.

\subsubsection{Spielende}
\label{ssub:spielende}
Das Ende des Spieles wird mittels der Nachricht SpielEnde den Spielern mitgeteilt.

\clearpage
\subsection{Nachrichten \& Events}
\label{sub:nachrichten_und_events}


\subsubsection{Events}
\label{ssub:events}

\begin{itemize}
	\item VerbindeEvent
	\item KarteGewaehltEvent
	\item BewegungEingegebenEvent
\end{itemize}

\subsubsection{Nachrichten}
\label{ssub:nachrichten}

\begin{itemize}
	\item SpielBeitreten
	\item BeitrittsBestaetigung
	\item SpielStartNachricht
	\item SpielVollNachricht
	\item ZugAuffoderung
	\item ZugInformation
	\item ChatNachricht
	\item RundenStart
	\item KartenTausch
	\item SpielEnde
\end{itemize}

\clearpage
\section{Dynamische Abläufe}
\label{dynamische_ablauefe}
\subsection{Nachrichtenfluss durch die Schichten}
\label{sub:nachrichtenfluss_durch_die_schichten}
Die Abbildungen~\vref{fig:sd_verbindung_erstellen_client} und~\vref{fig:sd_verbindung_erstellen_server} zeigen den Schnitt durch die Architektur von Bodesuri. Sie zeigen die Aufrufe durch die Architekturschichten beim Erstellen einer neuen Verbindung auf der Seite des Clients und des Servers.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{sd_verbindung_erstellen_client}
	\caption{Sequenzdiagramm Verbindung erstellen -- Client}
	\label{fig:sd_verbindung_erstellen_client}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{sd_verbindung_erstellen_server}
	\caption{Sequenzdiagramm Verbindung erstellen -- Server}
	\label{fig:sd_verbindung_erstellen_server}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{sd_verbindung_erstellen_endpunkt}
	\caption{Sequenzdiagramm Verbindung erstellen -- EndPunkt}
	\label{fig:sd_verbindung_erstellen_endpunkt}
\end{figure}

\subsection{Rundenstart}
\label{sub:rundenstart}
Die Abbildung~\vref{fig:dienste_rundenstart} zeigt den Ablauf beim Start einer neuen Runde.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.7 \textwidth]{dienste_rundenstart}
	\caption{Sequenzdiagramm Rundenstart}
	\label{fig:dienste_rundenstart}
\end{figure}

\clearpage
\subsection{Validierung von Spielzügen}
\label{ssub:validierung_von_spielzügen}
Abbildung~\vref{fig:pd_validierung} zeigt die Validierung der Spielzüge.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{pd_validierung}
	\caption{Sequenzdiagramm Validierung von Spielzügen}
	\label{fig:pd_validierung}
\end{figure}

\clearpage
\subsection{Serialiserung}
\label{sub:serialiserung}
Abbildung~\vref{fig:dienste_serialisierung} zeigt den Ablauf bei der Serialisierung von Objekten, damit sie über das Netzwerk übertragen werden können.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dienste_serialisierung}
	\caption{Sequenzdiagramm Serialisierung}
	\label{fig:dienste_serialisierung}
\end{figure}

\clearpage

\subsection[Partnerschaften bilden]{Partnerschaften bilden\footnote{Wurde nicht implementiert.}}
\label{sub:partnerschaften_bilden}

Abbildung~\vref{fig:dienste_partner} zeigt die möglichen Zustände beim Finden eines Partners.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dienste_partner}
	\caption{Zustandsdiagramm Partnerschaften bilden}
	\label{fig:dienste_partner}
\end{figure}

Die Abildung~\vref{fig:dienste_partnerschaft_normal} zeigt Ablauf des Bildens von Partnerschaften.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dienste_partnerschaft_normal}
	\caption{Sequenzdiagramm Partnerschaften bilden}
	\label{fig:dienste_partnerschaft_normal}
\end{figure}

\clearpage
\subsection{Chat}
\label{sub:nachrichtenaustausch_zwischen_client_und_server}
Abbildung~\vref{fig:dienste_chat} zeigt den Verlauf des Austausches von Nachrichten zwischen den Clients und dem Server am Beispiel einer Chat-Nachricht.
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{dienste_chat}
	\caption{Sequenzdiagramm Chat}
	\label{fig:dienste_chat}
\end{figure}

\clearpage
\section{Externes Design}
\label{externes_design}

\subsection{Verbinden}

Beim Starten des Spiels wird der Spieler aufgefordert, die Serverdaten zur Verbindung und seinen Spielernamen einzugeben.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7 \textwidth]{gui_verbindung}
	\caption{Design Verbinden}
	\label{fig:gui_verbindung}
\end{figure}

\clearpage

\subsection{Lobby}
\label{externes_design_lobby}

In der Lobby können die Spieler einen Partner für das Spiel auswählen\footnote{Wurde nicht implementiert.}. Der ausgewählte Partner muss die Anfrage akzeptieren, um die Gruppe zu bilden. Sobald der Spieler bereit ist, das Spiel zu beginnen, wählt er im Spielstatus "<bereit"> aus. In der Zwischenzeit können sich die Spieler im Chat unterhalten.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9 \textwidth]{gui_lobby}
	\caption{Design Lobby}
	\label{fig:gui_lobby}
\end{figure}

\clearpage

\subsection{Spiel}
\label{externes_design_spielbrett}

Das Spiel besteht aus verschiedenen Views:
\begin{itemize}
	\item In der BrettView wird das Spielbrett mit den Feldern und Spielfiguren dargestellt.
	\item In der SpielerView werden die einzelnen Spieler mit Gruppenzugehörigkeit aufgelistet.
	\item Die KartenView beinhaltet die Karten des Spielers.
	\item In der ChatView können sich die Spieler unterhalten.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9 \textwidth]{gui_spiel}
	\caption{Design Spiel}
	\label{fig:gui_spiel}
\end{figure}

\clearpage
\section{Designentscheidungen}

\subsection{Zustandsautomat}
Unser Spiel hat einen komplexen Ablauf, sowohl auf der Client- als auch auf der Serverseite. Der grösste Teil der Abläufe wird von Events im Userinterface oder von Netzwerk-Nachrichten ausgelöst. Darum haben wir uns entschlossen, den Spielablauf in einem Zustandsautomaten zu verpacken.

Damit ist es möglich, den Programmablauf, der sonst in komplexem nacheinander aufzurufendem Programmcode verpackt wäre, in verschiedene Klassen auszulagern und den \emph{Gap} zwischen dem Code und den in der Elaboration gezeichneten Zustandsdiagrammen klein zu halten.

\subsection{Synchronisation UI/Automat}

Bodesuri verwendet für die Ablaufsteuerung und die interne Zustandssynchronisation zwischen Client und Server Zustandsautomaten. Der Zustandsautomat des Clients ist zusätzlich noch für die saubere Einbindung der darüber liegenden Schicht verantwortlich, zurzeit das GUI mit seinem Controller. Es stellte sich früh heraus, dass auch GUI und Automat gut synchronisiert werden müssen, so muss z.\,B. die Kartenauswahl im GUI deaktiviert werden, sobald eine Karte gewählt wurde. Wird dies nicht gemacht, kann der Automat bei Fehleingaben (der Benutzer wählt eine weitere Karte obwohl bereits getauscht) Events erhalten, welche in einem anderen Zustand gar keinen Sinn mehr ergeben und zu einer Exception führen.

Die offensichtliche Lösung für das Problem wäre eine kontrollierte Aktivierung und Deaktivierung aller GUI-Elemente in den betroffenen Zuständen, sprich das GUI in den Zustandsablauf einzubinden. Zum Beispiel könnte der Zustand Kartenwahl bei Zustandseintritt die Auswahl aktivieren und beim Verlassen des Zustands wieder deaktivieren. Eine solche Lösung ist aber leider auch mit Problemen verbunden. Das GUI und seine Komponenten laufen in eigenen Threads und können noch während der Verarbeitung des Zustands weiter agieren. Zum Beispiel könnte sich der Automat in der Verarbeitung der Kartenwahl befinden während das GUI, im Glauben es sei immer noch im gleichen Zustand, einen weiteren Kartenwahl-Event auslösen. Passiert dies, führt es höchstwahrscheinlich zu einem unerwarteten Event (Out-Of-State-Event) und somit zum kontrollierten, aber sinnlosen, Absturz.

Damit diese offensichtliche Lösung (zustandsbewusstes GUI) funktionieren könnte, müsste die Event-Verarbeitung von GUI und Automaten irgendwie koordiniert werden.

Folgende Varianten standen zur Auswahl:

\begin{itemize}
	\item GUI-Elemente werden bereits im ActionHandler des GUIs deaktiviert
	\begin{itemize}
		\item \textbf{Vorteil:} Keine Race-Conditions möglich
		\item \textbf{Nachteil:} Viel Zustandslogik im GUI, Erweiterungen sind aufwändig ("<in welchen Handlers muss ich das noch deaktivieren">)
	\end{itemize}
	\item GUI blockiert bis Automat abgearbeitet wird / Synchrone Event-Verarbeitung
	\begin{itemize}
		\item \textbf{Vorteil:} Keine Race-Conditions möglich, einfache Handhabung seitens GUI
		\item \textbf{Nachteil:} GUI könnte unter Umständen träge wirken, komplizierte Umsetzung
	\end{itemize}
\end{itemize}

Ein ganz anderer Ansatz besteht darin, das GUI ganz von den Zuständen zu entkoppeln. Das GUI könnte jederzeit Events auslösen und es wäre die Aufgabe des Zustandsautomaten zu erkennen, ob diese Events im gegebenen Zustand Sinn ergeben oder halt eben nicht. Natürlich könnten einzelne Bedienelemente trotzdem Zustandsabhängig aktiviert \& deaktiviert werden (z.\,B. um die Benutzerfreundlichkeit zu erhöhen) aber die korrekte Funktion des Automaten wäre davon unabhängig, er könnte problemlos mit "<Out-Of-State-Events"> umgehen.

\textbf{Vorteile:}
\begin{itemize}
	\item GUI simpler, entkoppelt von Zuständen
	\item Keine komplizierte Synchronisation mit Swing
\end{itemize}

\textbf{Nachteile:}
\begin{itemize}
	\item Automat ist bei GUI-Events weniger strikt\footnote{Der Automat ist in allen anderen Bereichen sehr strikt, was eine frühe Fehlererkennung mit sich bringt. Zum Beispiel können bei Events zur Synchronisation mit dem Server keine \emph{Fehler} toleriert werden.}
\end{itemize}

Wir entschieden uns aufgrund der genannten Vorteile für die Implementierung der dritten Variante.

\subsection{Kommunikation GUI/Automat}

Im Laufe der Phase \emph{Construction 1} zeigten sich erste Schwierigkeiten mit der Implementierung des Controllers. Ursprünglich war geplant, dass sich alle UI-Elemente, die direkt durch den Automaten kontrolliert werden müssen, beim Controller registrieren. Der Controller hätte dann die Elemente, je nach Anweisung des Automaten, direkt manipulieren können. Leider hatte dies verschiedene Nachteile. Einerseits war mit diesem System das GUI und der Controller extrem eng verknüpft. Dies zeigte sich in verschiedensten zyklischen Abhängigkeiten. Andererseits war aber auch der Code teilweise schwer nachvollziehbar, weil plötzlich gewisse GUI-Logik in Mouse-Adaptern und ähnlichen Klassen steckte. Zusätzlich wurde, da jede auch noch so kleine UI-relevante Zustandsänderung gemeldet werden musste, der Controller immer komplizierter und war schwer zu durchschauen.

Wir analysierten die Situation und kamen nach einigen Diskussionen zum Schluss, dass ein alternatives Kommunikations-Modell die Kommunikation vereinfachen könnte. Zusätzlich setzten wir uns das Ziel, dass das GUI nichts mehr direkt über den GUIController wissen muss. 

Das neue Modell sah vor, dass der grosse Teil der Kommunikation über Observer passieren sollte. Also z.\,B. das Feld weiss von sich selber ob es zurzeit ausgewählt ist und meldet etwaige Zustandswechsel über Observer-Event an das GUI. Dieses neue Konzept stellte uns plötzlich vor ein weiteres Problem. Wir sahen, dass wir plötzlich ganz viele, für die PD nicht relevante, Informationen in der Problem-Domain hätten ablegen müssen. Auf Grund der komplexen Regel-Logik war die Problem-Domain jedoch bereits relativ kompliziert. 

Um eine Vergrösserung der Problem-Domain zu verhindern begannen wir, einige ihrer Teile in Form von \emph{Dekoratoren} in der Applikationsschicht abzubilden. Diese Dekoratoren bildeten mehr oder minder dieselbe Funktionalität\footnote{Dafür leiteten sie die Methodenaufrufe einfach direkt in die darunterliegende Schicht weiter.} ab und observierten die jeweils dekorierten Objekte in der Problem-Domain. Zusätzlich beinhalteten sie aber Felder und Logik, die nur für die Applikationschicht relevant sind, so zum Beispiel den aktuellen Selektierungszustand.

Mit diesem System wird das User-Interface über alle Änderungen informiert, sei es nun eine Änderung am PD-Objekt oder am Dekorator in der Applikationsschicht. Sollte eine alternative GUI-Implementierung kein Interesse an diesen Events haben, kann es diese entweder ignorieren oder sich gar nicht erst als Observer registrieren.

Diese Änderungen zog grössere Arbeiten nach sich, aber unter dem Strich hat sie die Logik bedeutend einfacher gemacht. Es hätte jedoch einige doppelte Arbeit erspart werden können, wenn diese bessere Lösung früher erkannt worden wäre.

\subsection{Multitier-Architektur des Servers}
Der Server wurde in mehrere Schichten und vertikal angeordnete Partitions aufgeteilt. Diese Hierarchie hat sich deshalb als erforderlich erwiesen, da sonst Abhängigkeiten von tieferliegenden zu höherliegenden Schichten entstehen würden.

\subsection{Applikationsschicht}
Die Applikationsschicht wurde eingeführt, weil es wegen der Netzwerkfähigkeit viel Synchronisationsarbeit (z.\,B. für Zustände) gibt. Sie hat folgende Hauptaufgaben:
	\begin{itemize}
		\item Zustandssynchronisation als erste Vorstufe der Netzwerkkommunikation. Spezifische Nachrichten werden eingepackt, an die darunterliegenden Schichten weitergeleitet, um dann über das Netzwerk verteilt und empfangen zu werden.
		\item Controller-Komponente des MVC-Konzeptes, welche die Ereignisse im UI abfängt und verarbeitet, sowie Änderungen in der Problem-Domain an das UI weiterleitet.
	\end{itemize}

\subsection{Regelverstoss als Exception}

Wenn eine Zug getätigt werden soll, wird zuerst mit den Angaben des Benutzers eine ZugEingabe zusammengestellt. Diese wird dann vom Regelsystem auf Gültigkeit geprüft (Methode \texttt{validieren}), wobei es zwei mögliche Ergebnisse gibt:
\begin{itemize}
	\item Die ZugEingabe ist gültig und das Resultat ist ein ausführbarer Zug, der von der Regel zusammengestellt wurde.
	\item Die ZugEingabe ist ungültig und das Resultat ist ein Verstoss mit einer Erklärung, warum die ZugEingabe ungültig ist.
\end{itemize}

Eine Möglichkeit, diese beiden Ergebnisse von einer Methode zurückzugeben ist, eine Klasse zu machen, die beides beinhalten kann, oder eine Basisklasse mit zwei sehr unterschiedlichen Resultat-Unterklassen. Mit dieser Variante wird jedoch sowohl der Code der \texttt{validieren}-Methode als auch der aufrufende Code komplizierter als nötig, da immer eine Fallunterscheidung gemacht werden muss. Wird zum Beispiel der Code von \texttt{validieren} in mehrere kleine Untermethoden zerlegt, muss bei jedem Aufruf der Rückgabewert geprüft werden und je nachdem mit der Validierung weitergemacht oder aufgehört werden.

Eine zweite Variante wäre, das Ergebnis der letzten Validierung in einer ständig vorhandenen Klasse zu speichern, wo es bei Bedarf abgerufen werden kann. Der Nachteil daran ist, dass das Ergebniss entkoppelt vom Aufruf von \texttt{validieren} an einem anderen Ort abgeholt werden muss, was nicht intuitiv ist und die beiden Klassen sehr stark voneinander Abhängig macht.

Die dritte und schliesslich implementierte Variante ist, bei Gültigkeit einen Zug zurückzugeben und andernfalls eine Exception des Typs \texttt{RegelVerstoss} zu werfen. Damit sind die Nachteile beider oben genannten Varianten beseitigt, die beiden verschiedenen Resultate sind sauber getrennt und aufrufender Code wird zudem noch gezwungen, den Fehlerfall zu behandeln (\texttt{RegelVerstoss} ist \emph{checked}).

\subsection{Mögliche Züge in Regel}

Die folgenden beiden Methoden in \texttt{Regel} haben ganz ähnliche Funktionen:

\begin{itemize}
	\item \texttt{istZugMoeglich} findet heraus, ob mit dieser Regel für den übergebenen Spieler noch ein Zug möglich ist.
	\item \texttt{getMoeglicheZuege} findet alle möglichen ZugEingaben mit dieser Regel für den übergebenen Spieler.
\end{itemize}

Wie werden diese implementiert? Es wäre natürlich möglich, \texttt{istZugMoeglich} anhand von \texttt{getMoeglicheZuege} zu definieren, indem geschaut wird, ob diese eine leere Liste zurückgibt. Dies kann aber rechenintensiv sein, da in jedem Fall alle Möglichkeiten durchgegangen werden, obwohl das nicht nötig ist.

Eine andere Variante wäre, den Code einfach zu kopieren und jeweils einen kleinen Teil darin anzupassen, um den Anforderungen an die beiden Methoden gerecht zu werden. Dies hätte aber duplizierten Code zur Folge und eine erschwerte Anpassbarkeit, da jeweils in zwei Funktionen der gleiche Code angepasst werden müsste.

% TODO: Wie heisst das Pattern, das ähnlich ist?

Deshalb entschieden wir uns, die folgende Variante zu implementieren. Es wird eine interne (\emph{protected}) dritte Methode erstellt, die \texttt{liefereZugEingaben} heisst. Diese übernimmt die gleichen Argumente wie die beiden obengenannten Methoden und zusätzlich noch ein Objekt des neuen Typs \texttt{ZugEingabeAbnehmer}. Die Methode liefert dem Abnehmer über \texttt{nehmeEntgegen} eine Zugeingabe und stellt anhand des Rückgabewertes fest, ob mit der Suche abgebrochen werden soll.

Die Methode \texttt{istZugMoeglich} ruft \texttt{liefereZugEingaben} mit einem Abnehmer auf, der nur auf die erste Zugeingabe wartet, einen Wert setzt, und signalisiert, dass abgebrochen werden kann. Danach wird der Wert ausgelesen und je nachdem zurückgegeben, ob ein Zug möglich ist oder nicht.

Für \texttt{getMoeglicheZuege} wird ein Abnehmer verwendet, der alle Zugeingaben speichert und immer zurückgibt, dass er weitere wünscht.

Mit dieser Lösung ist der Code zur Findung von Zugeingaben nur einmal vorhanden und die beiden Methoden laufen trotzdem nur so lange wie nötig.

\clearpage
\section{Eingetretene Risiken}
\label{eingetretene_risiken}

\subsection{RMI}
\label{sub:rmi}

Im Verlauf der ersten Tests mit RMI stellte sich schnell heraus, dass RMI weit mehr kann als für das Projekt notwendig wäre und es dem Projekt somit unnötig Komplexität hinzufügt. Andererseits stellt RMI  einige Anforderungen an die Client/Server-Struktur, die sich nur schwer mit den Projektanforderungen decken lassen. So kann RMI nur erschwert hinter Firewalls betrieben werden und eine Kommunikation über ein durch NAT\footnote{Network Adress Translation. Firewall-Feature welches Netzbereiche auf andere Netzbereiche abbildet. Wird häufig verwendet, um private Adressbereiche im Internet hinter einer einzelnen Adresse zu verstecken.} verstecktes Netzwerk ist gar nicht erst möglich. Da die Internet-Zugangslösungen in den meisten Haushalten auf Firewalls und NAT basieren, könnte das Spiel von einem grösseren Teil der potenziellen Kundschaft gar nicht gespielt werden.

Wir entschieden uns aufgrund dieser Probleme, auf eine eigene Lösung umzusteigen, welche auf den Java-Klassen Socket und Object(Input|Output)Stream basiert. Insgesamt gingen etwa 10 Stunden Arbeit für diese Umstellung verloren.

\subsection{Java 2D}
\label{java_2d}

Nachdem das CLI (Command Line Interface) erstellt war, entwarfen wir ein GUI dafür, das die Felder und Figuren darstellen sollte. Mit Java 2D ist das Zeichnen sehr einfach, da man die Koordinaten der zu zeichnenden Elemente angeben kann. Doch mussten wir leider feststellen, dass das Ansprechen eines Objektes etwas komplizierter ist. So muss zum Beispiel bei einem Mausklick das geklickte Objekt über die Koordinaten ermittelt werden. Ausserdem muss man sich um das Aktualisieren der Anzeige bei Veränderungen selber kümmern.

In einem zweiten Versuch erstellten wir das selbe Spielbrett mit Swing und wir kamen zum Schluss, dass dies die einfachere Methode ist. Die Objekte können mit einem speziellen Layout auch auf Koordinaten genau platziert werden und Klicke darauf kann man wie gewohnt mit einem MouseListener abfangen. Als Objekt kann man zum Beispiel ein Label mit einem Icon verwenden. Dies reicht für ein Brettspiel vollkommen aus.

Aus diesen Gründen haben wir uns dazu entschlossen, für das GUI als einzige Technologie Swing einzusetzen. Insgesamt gingen 7.5 Stunden Arbeit für diese Umstellung verloren.

\clearpage
\section{Besser als erwartet}

Einige Dinge, von denen wir dachten, sie würden viel Zeit brauchen, waren einfacher zu implementieren als erwartet.

\subsection{Serialisierung}

Um Objekte über das Netzwerk zu schicken, müssen sie serialisiert werden, das heisst den Zustand eines Objektes so in eine binäre Form zu bringen, dass es an einem anderen Ort oder zu einem anderen Zeitpunkt eingelesen werden kann, um wieder den ursprüngliche Zustand des Objektes zu erhalten.

Normalerweise ist das Objekt an einem Ort vorhanden und am anderen nicht. In unserem Fall müssen aber alle Objekte der Problem-Domain sowohl auf jedem Client als auch auf dem Server bereits existieren. Wenn nun ein Objekt übertragen wird, wird am empfangenden Ort ein neues Objekt erstellt, das zwar die gleichen Daten hat, aber nicht die gleiche Identität (gleiche Speicheradresse) wie das bereits vorhandene Objekt. Wenn dann mit dem empfangenen Objekt etwas gemacht wird, wird das z.\,B. vom GUI, welches das bereits vorhandene Objekt observiert, nicht bemerkt.

Für diese Problemstellung wird also ein Mechanismus gebraucht, der bei der Deserialisierung nicht neue Objekte, sondern die bereits vorhandenen zurückliefert. Dies ist bei der Java-Serialisierung mit den beiden Methoden \texttt{writeReplace} (beim zu schreibenden Objekt) und \texttt{readResolve} (beim einzulesenden Objekt) möglich, wo jeweils Objekte zurückgegeben werden können, die dann anstelle der ursprünglichen verwendet werden.

Damit ist die Grundlage für eine Serialisierung wie wir sie brauchen vorhanden. Darauf aufbauend ist nun noch eine eindeutige Codierung der Objekte nötig, die auf jedem Rechner gleich sein muss. Der Ablauf einer Übertragung eines Objektes ist dann wie folgt:

\begin{enumerate}
	\item Beim zu schreibenden Objekt (zum Beispiel \texttt{Feld}) wird in \texttt{writeReplace} ein \texttt{CodiertesObjekt} zurückgeliefert, welches nur einen Code enthält, der dieses Objekt eindeutig identifiziert (zum Beispiel \texttt{Feld 47}).
	\item Das stellvertretende Objekt wird über das Netzwerk geschickt.
	\item Beim Einlesen von \texttt{CodiertesObjekt} wird von Java die Methode \texttt{readResolve} aufgerufen, welche in einer Tabelle zum Code das dazugehörige Objekt nachschaut und zurückgibt.
\end{enumerate}

Dank der Serialisierungsschnittstelle von Java ist diese Lösung transparent. Der Vorgang ist in Abbildung~\vref{fig:dienste_serialisierung} detailliert als Sequenzdiagramm dargestellt.


\clearpage
\listoffigures

\end{document}
